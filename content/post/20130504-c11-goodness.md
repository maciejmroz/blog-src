+++
title = "C++11 Goodness"
date = "2013-05-04"
slug = "c11-goodness"
categories = [ "Programming" ]
tags = [ "C++", "C++11"]
+++

While most of my programming life used to be centered around C++, nowadays I do not really spend much time with the language at work (other than doing code reviews). I remain big fan of C++. Despite the fact it's not very fashionable language, it is extremely efficient and quite flexible. What's even more important it's continuing to evolve, and it evolves in the right direction. I took some time to try out the C++11 features refactoring small private project, and it really looks good.

First of all: lambdas. This feature alone is a killer. C++ used to have "sort of lambdas" in the form of boost::lambda library, but this library was insanely hard to use beyond simple use cases, the syntax was alien, and when it broke the compiler errors were cryptic. It didn't stop me from trying to use it, only to come up with the conclusion it doesn't really improve my productivity in any way. I never used boost::lambda in any production code. C++11 lambdas are not like that. The lambda function body is written using normal C++ syntax. It's ordinary code, just as readable as any other code. There's no complex template voodoo happening. It looks just like any other function except for special syntax used to define it in place. If you do something wrong in the lambda, the compiler errors are what anyone would expect them to be. Ok, it's all nice, but why all the fuss about anonymous functions? Because they are much more than just that! Using the variable capture specification you can create real closures. That's closures as in: "Lisp has closures". It means you can access enclosing state in the lambda body. All these small functors that proliferate like crazy when writing STL code are just not necessary any more! As a side note, you don't have to use bind, either, because lambdas are perfectly fine as "glue code"! We get cleaner, shorter and more maintainable code, all thanks to the fact that compiler does what had to be done manually in the past. It doesn't matter if it's writing new code, or refactoring part of existing application. Lambdas offer real gains to productivity.

Another feature that's similar in spirit, although much smaller in impact is range based for loop. It is so straightforward to use that I consider it a sin to use begin(), end() and temporary iterator in new code. There's not much more to be said about it :) How about other C++11 language features? It's the first published ISO C++ standard for many years, so there are a lot of new things!

Some of the features go along the same path of nicer syntax at the cost of making compiler a bit smarter (that's for example 'auto' keyword), others like rvalue references (combined with move constructors) go towards efficient code that looks more natural (possibly offering performance gains to some bad pre-C++11 code, because STL was updated to make use of move constructors).

I don't think a blog post is right place to review all new things in C++, the changes are simply too vast to cover fully in so small space (especially considering that some of these deserve a blog post on their own :) ). I strongly suggest checking Wikipedia or other source for the details - it's really worth it. I am not going to cover standard library changes here, too. Any self respecting C++ developer is already using boost, so there's nothing new. The decision on whether to move to std:: versions of libraries is "case by case" one - there are no clear wins here.

Only very recently we got the first compiler that fully implements the standard (that's Clang). Still, most of C++11 language can be used on any relatively recent compiler. I tried my code on both Visual Studio 2012 and Clang 3.2 (that's default for Xcode on Mac OS X) and had zero problems with building it. Gcc seems to be very close to fully supporting the standard, too - although in case of gcc you will likely be forced to upgrade it manually (i.e. current CentOS Linux ships with gcc 4.4.x, which is ancient â€¦).

Considering that some investment is needed to upgrade to start using C++11, should you do it? New standard is obviously cool for developers, but that's not where value comes from (although employee engagement has value, it's a bit intangible). This time it's all about the value that comes from productivity and code quality improvements, and that makes the decision to migrate towards C++11 very simple from business point of view.